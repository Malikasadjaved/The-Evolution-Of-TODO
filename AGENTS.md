# AGENTS.md - AI Agent Development Guide

> **üìò For AI Agents (Claude Code, etc.)**
> This file provides essential context, constraints, and workflow guidance for AI agents working on Phase 3: AI Chatbot with MCP Architecture.

---

## üèõÔ∏è Constitutional Foundation

**Primary Reference**: [`.specify/memory/phase-3-constitution.md`](.specify/memory/phase-3-constitution.md)

All architectural decisions, technology choices, and implementation approaches **MUST** comply with the Phase 3 Constitution (v1.1.0). This constitution is **NON-NEGOTIABLE** and overrides any conflicting instructions.

**Quick Constitution Access**:
- Phase 1: `.specify/memory/constitution.md` (CLI app principles - preserved for reference)
- Phase 2: `.specify/memory/phase-2-constitution.md` (web app - currently deployed)
- **Phase 3**: `.specify/memory/phase-3-constitution.md` (AI chatbot - **ACTIVE**)

---

## ‚öñÔ∏è Three Core Principles (NON-NEGOTIABLE)

### Principle 1: Agentic Development Supremacy

**NO human shall write production code directly.**

```
Human Role: Architect, Reviewer, Prompt Engineer
AI Role:    Code Generator, Implementer, Tester
```

**What This Means**:
- ‚úÖ All code generated by Claude Code following Spec ‚Üí Plan ‚Üí Tasks ‚Üí Implementation workflow
- ‚úÖ Every code artifact must have full provenance (which prompt, which iteration)
- ‚úÖ Document every prompt, every iteration, every decision point (PHRs)
- ‚ùå NO manual coding - even "quick fixes" must go through the workflow
- ‚ùå NO copy-paste from external sources without workflow
- ‚ùå NO bypassing the spec/plan/tasks process

**Rationale**: This project validates agentic development methodology. Manual coding invalidates the experiment.

---

### Principle 2: Radical Statelessness

**The server is a pure function: `Request ‚Üí Response`. No memory between invocations.**

**The Stateless Covenant**:
```
‚àÄ request: server_state_before = server_state_after = ‚àÖ
```

**What This Means**:
- ‚úÖ FastAPI holds ZERO conversation context in RAM
- ‚úÖ Database is the single source of truth for ALL state
- ‚úÖ Fetch conversation history from DB on EVERY request
- ‚úÖ Server can restart mid-conversation without user impact
- ‚úÖ Load balancer can route request N to server A, request N+1 to server B
- ‚ùå NO `conversation_cache = {}`
- ‚ùå NO `@lru_cache` on conversation data
- ‚ùå NO "active sessions" tracking in memory

**Critical Implications for Planning**:
- Database queries on every request (optimize with indexes)
- Connection pooling required (50 connections per server instance)
- Conversation history truncation strategy needed (token limits)
- Health checks must verify database connectivity

**Rationale**: Horizontal scalability, fault tolerance, cloud-native architecture (Phase 4 Kubernetes deployment).

---

### Principle 3: MCP as the Universal Interface

**All AI-to-application interactions flow through MCP tools. No exceptions.**

**Architecture Law**:
```
Agent ‚Üí MCP Tool ‚Üí Database Operation ‚Üí Response ‚Üí Agent
```

**What This Means**:
- ‚úÖ Agent has ONE power: invoke MCP tools
- ‚úÖ Exactly 5 MCP tools: `add_task`, `list_tasks`, `complete_task`, `delete_task`, `update_task`
- ‚úÖ MCP tools are stateless (fetch data from DB on each invocation)
- ‚úÖ Agent orchestrates multi-tool workflows
- ‚ùå Agent CANNOT touch database directly
- ‚ùå Agent CANNOT call FastAPI endpoints
- ‚ùå Agent CANNOT access file system
- ‚ùå MCP tools NEVER call each other

**Critical Implications for Planning**:
- MCP server is a separate component (`backend/mcp/`)
- Each tool is a standalone function with clear input/output contract
- Tools must filter ALL queries by `user_id` (security)
- Tools return structured data (Pydantic models), not raw DB objects

**Rationale**: Standardized, auditable, replaceable AI integration. Agent vendors can change; MCP contract remains stable.

---

## üõ†Ô∏è Technology Stack (IMMUTABLE)

These technology choices are **LOCKED** by the constitution. Do NOT suggest alternatives.

| Layer | Technology | Version | Notes |
|-------|-----------|---------|-------|
| **Frontend** | OpenAI ChatKit | Latest | Official chat UI library |
| **Backend API** | Python FastAPI | 0.100+ | Async endpoints |
| **AI Framework** | OpenAI Agents SDK | Latest | For agent orchestration |
| **MCP Server** | Official MCP SDK | Latest | Python implementation |
| **ORM** | SQLModel | 0.0.14+ | Type-safe database queries |
| **Database** | Neon PostgreSQL | Serverless | **SHARED with Phase 2** |
| **Authentication** | Better Auth | Latest | **SHARED with Phase 2** - JWT tokens |

### Forbidden Substitutions

**Do NOT suggest**:
- ‚ùå LangChain instead of OpenAI Agents SDK
- ‚ùå Prisma instead of SQLModel
- ‚ùå Supabase instead of Neon PostgreSQL
- ‚ùå Auth0 instead of Better Auth
- ‚ùå Any other database (MySQL, MongoDB, SQLite)
- ‚ùå Any other framework (Django, Flask, Express)

If you encounter a limitation with the mandated stack, **document the constraint** and propose a workaround within the stack, NOT a technology swap.

---

## üìã SpecifyPlus Workflow (MANDATORY)

All development follows this strict sequence:

```
1. /sp.specify ‚Üí specs/<feature>/spec.md
2. /sp.plan    ‚Üí specs/<feature>/plan.md
3. /sp.tasks   ‚Üí specs/<feature>/tasks.md
4. IMPLEMENT   ‚Üí Execute tasks via Claude Code
5. /sp.phr     ‚Üí history/prompts/<feature>/<ID>-<slug>.prompt.md
```

### Phase Breakdown

#### **Phase 1: Specification** (`/sp.specify`)
- **Input**: Natural language feature description
- **Output**: `specs/002-ai-chatbot-mcp/spec.md` ‚úÖ **COMPLETED**
- **What**: User stories, functional requirements, success criteria, key entities
- **Constraints**: Technology-agnostic, testable requirements, measurable success criteria
- **Validation**: Zero [NEEDS CLARIFICATION] markers, all quality checks PASS

#### **Phase 2: Planning** (`/sp.plan`) ‚¨ÖÔ∏è **YOU ARE HERE**
- **Input**: Approved specification
- **Output**: `specs/002-ai-chatbot-mcp/plan.md`
- **What**: Architecture decisions, component breakdown, data models, API contracts, risk analysis
- **Constraints**:
  - MUST reference constitution principles
  - MUST identify Phase 2 integration points (shared models, database, auth)
  - MUST design for statelessness (no in-memory state)
  - MUST define MCP tool contracts (5 tools only)
  - MUST use ONLY technologies from the immutable stack
  - MUST plan for cloud-native deployment (12-factor app)

#### **Phase 3: Task Breakdown** (`/sp.tasks`)
- **Input**: Approved plan
- **Output**: `specs/002-ai-chatbot-mcp/tasks.md`
- **What**: Atomic, independently testable tasks with acceptance criteria
- **Constraints**: Each task must be completable in < 2 hours, must have clear test cases

#### **Phase 4: Implementation**
- **Input**: Task list
- **Output**: Working code via Claude Code
- **What**: Execute tasks sequentially, write tests first (TDD), generate code
- **Constraints**: NO manual coding, document every iteration with PHRs

#### **Phase 5: Documentation** (`/sp.phr`)
- **Input**: Completed work
- **Output**: Prompt History Records in `history/prompts/002-ai-chatbot-mcp/`
- **What**: Capture prompt, response, outcome, reflection for learning

---

## üîó Phase 2 Integration Points (CRITICAL)

Phase 3 is NOT a standalone project. It **extends** the existing Phase 2 monorepo.

### Shared Components (DO NOT RECREATE)

#### **1. Database Models** (`backend/src/models/`)

**Reuse from Phase 2**:
- `Task`: `id, user_id, title, description, priority, tags, due_date, status, created_at, updated_at`
- `User`: `id, email, hashed_password, created_at`

**Add for Phase 3** (in same `models/` directory):
- `Conversation`: `id, user_id, created_at, updated_at`
- `Message`: `id, conversation_id, role, content, created_at`

**Critical**: Do NOT modify existing `Task` or `User` schemas. Phase 2 web UI depends on them.

#### **2. Authentication** (`backend/src/api/auth.py`)

**Reuse from Phase 2**:
- Better Auth JWT middleware
- Token verification logic (extracts `user_id` from JWT payload)
- 401/403 error handling

**For Phase 3**:
- Chat endpoint MUST use the same JWT middleware
- No new authentication logic - reuse existing

**Critical**: JWT tokens issued by Phase 2 MUST work in Phase 3 (same secret, same payload structure).

#### **3. Database Connection** (`backend/src/database/`)

**Reuse from Phase 2**:
- Neon PostgreSQL connection configuration
- Connection pooling setup
- Migration scripts

**For Phase 3**:
- Add migrations for `conversations` and `messages` tables
- Do NOT change connection string or pooling config

**Critical**: Same database instance. Tasks created in chatbot appear in web UI immediately.

#### **4. Environment Variables** (`.env`)

**Shared**:
- `DATABASE_URL` - Neon PostgreSQL connection string
- `BETTER_AUTH_SECRET` - JWT signing secret (MUST match Phase 2)

**New for Phase 3**:
- `OPENAI_API_KEY` - OpenAI API access
- `MCP_SERVER_URL` - MCP server endpoint (if separate process)

**Critical**: Never hardcode secrets. Load from environment only.

### Data Flow Between Phases

```
Phase 2 Web UI (frontend-web/) ‚îÄ‚îÄ‚îê
                                  ‚îú‚îÄ‚îÄ‚Üí Neon PostgreSQL (tasks table)
Phase 3 Chatbot (frontend-chatbot/) ‚îÄ‚îÄ‚îò

User creates task in web UI ‚Üí Chatbot sees it in next message
User creates task in chatbot ‚Üí Web UI shows it on refresh (< 1 second)
```

**Validation Criteria**:
- [ ] Same user account works in both UIs (shared `users` table)
- [ ] Tasks are synchronized (shared `tasks` table)
- [ ] JWT tokens from Phase 2 work in Phase 3 (shared secret)

---

## üìê Planning Phase Guidance (FOR /sp.plan)

When you execute `/sp.plan`, you MUST address the following:

### 1. Architecture Decisions

**Required Sections**:
- **Four-Layer Architecture**: ChatKit UI ‚Üí FastAPI Endpoint ‚Üí OpenAI Agent ‚Üí MCP Tools ‚Üí Database
- **Statelessness Strategy**: How to load conversation history on every request (database queries, caching strategy, token limit handling)
- **MCP Tool Contracts**: Define input/output schemas for all 5 tools (add_task, list_tasks, complete_task, delete_task, update_task)
- **Error Handling**: Circuit breaker for OpenAI API failures, fallback messages, timeout handling
- **Security**: JWT validation flow, user isolation enforcement, input sanitization

### 2. Component Breakdown

**Required Components**:
- `backend/src/api/chat.py` - Chat endpoint (POST /api/chat/{user_id})
- `backend/mcp/server.py` - MCP server initialization
- `backend/mcp/tools/add_task.py` - Tool implementation
- `backend/mcp/tools/list_tasks.py` - Tool implementation
- `backend/mcp/tools/complete_task.py` - Tool implementation
- `backend/mcp/tools/delete_task.py` - Tool implementation
- `backend/mcp/tools/update_task.py` - Tool implementation
- `backend/src/models/conversation.py` - New model
- `backend/src/models/message.py` - New model
- `frontend-chatbot/` - OpenAI ChatKit integration

### 3. Database Schema Changes

**New Tables**:
```sql
-- Conversations table
CREATE TABLE conversations (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- Messages table
CREATE TABLE messages (
    id UUID PRIMARY KEY,
    conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) CHECK (role IN ('user', 'assistant')),
    content TEXT,
    created_at TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
```

### 4. API Contracts

**Chat Endpoint**:
```
POST /api/chat/{user_id}
Headers: Authorization: Bearer <jwt_token>
Request: { "message": "Add task to buy milk" }
Response: { "response": "I've created a task...", "conversation_id": "uuid" }
```

**MCP Tool Example**:
```python
# Input
{
  "user_id": "uuid",
  "title": "Buy milk",
  "priority": "HIGH",
  "due_date": "2025-12-26T17:00:00Z"
}

# Output
{
  "id": "uuid",
  "user_id": "uuid",
  "title": "Buy milk",
  "status": "INCOMPLETE",
  "priority": "HIGH",
  "created_at": "2025-12-25T12:00:00Z"
}
```

### 5. Deployment Strategy

**12-Factor App Compliance**:
- Config via environment variables
- Stateless processes (horizontal scaling ready)
- Port binding (FastAPI serves on configurable port)
- Graceful shutdown (SIGTERM/SIGINT handlers)

**Health Checks**:
- `/health` - Liveness probe (returns 200 if server is running)
- `/ready` - Readiness probe (checks database + OpenAI API connectivity)

### 6. Testing Strategy

**Test Pyramid**:
- 50+ unit tests (MCP tools, database models, utility functions)
- 15+ integration tests (chat endpoint with mock OpenAI API, MCP tools with real database)
- 5+ E2E tests (full conversation flows: create task ‚Üí list tasks ‚Üí complete task)

**Coverage Requirements**:
- MCP tools: 100%
- Chat endpoint: 90%
- Database models: 80%
- Overall: ‚â• 85%

### 7. Risk Analysis

**Required Risk Sections**:
- OpenAI API cost overruns (mitigation: rate limiting, usage monitoring)
- OpenAI API latency/downtime (mitigation: circuit breaker, fallback messages)
- Conversation context loss (mitigation: sliding window truncation, summarization)
- MCP SDK immaturity (mitigation: early prototyping, fallback plan)
- Database performance degradation (mitigation: indexes, connection pooling, caching)

---

## üö® Common Pitfalls to Avoid

### ‚ùå Violating Statelessness

**WRONG**:
```python
# DO NOT DO THIS - in-memory session cache
conversation_sessions = {}  # ‚ùå Global state

@app.post("/chat/{user_id}")
def chat(user_id: str, message: str):
    if user_id not in conversation_sessions:
        conversation_sessions[user_id] = []  # ‚ùå Storing in memory
    conversation_sessions[user_id].append(message)
```

**CORRECT**:
```python
# ‚úÖ Fetch from database on every request
@app.post("/chat/{user_id}")
def chat(user_id: str, message: str, db: Session):
    # ‚úÖ Load conversation history from database
    conversation = db.query(Conversation).filter_by(user_id=user_id).first()
    messages = db.query(Message).filter_by(conversation_id=conversation.id).all()

    # ‚úÖ Process with OpenAI Agent
    response = agent.process(messages + [{"role": "user", "content": message}])

    # ‚úÖ Persist new messages to database
    db.add(Message(conversation_id=conversation.id, role="assistant", content=response))
    db.commit()
```

### ‚ùå MCP Tools Calling Each Other

**WRONG**:
```python
# DO NOT DO THIS - tool calling another tool
def complete_task(user_id: str, task_id: str):
    # ‚ùå Calling another MCP tool
    task = list_tasks(user_id, filter={"id": task_id})[0]
    task.status = "COMPLETE"
    return task
```

**CORRECT**:
```python
# ‚úÖ Each tool is independent, agent orchestrates
def complete_task(user_id: str, task_id: str, db: Session):
    # ‚úÖ Query database directly
    task = db.query(Task).filter_by(id=task_id, user_id=user_id).first()
    if not task:
        raise NotFoundError(f"Task {task_id} not found")
    task.status = "COMPLETE"
    task.updated_at = datetime.utcnow()
    db.commit()
    return task
```

### ‚ùå Bypassing JWT Validation

**WRONG**:
```python
# DO NOT DO THIS - trusting URL user_id
@app.post("/chat/{user_id}")
def chat(user_id: str, message: str):
    # ‚ùå Using URL user_id without validation
    tasks = db.query(Task).filter_by(user_id=user_id).all()  # Security hole!
```

**CORRECT**:
```python
# ‚úÖ Use token user_id, reject if mismatch
@app.post("/chat/{user_id}")
def chat(user_id: str, message: str, token_data: dict = Depends(verify_jwt)):
    # ‚úÖ Validate token user_id matches URL user_id
    if token_data["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # ‚úÖ Use token user_id for database queries
    tasks = db.query(Task).filter_by(user_id=token_data["user_id"]).all()
```

### ‚ùå Hardcoding Secrets

**WRONG**:
```python
# DO NOT DO THIS
OPENAI_API_KEY = "sk-abc123..."  # ‚ùå Hardcoded secret
BETTER_AUTH_SECRET = "my-secret"  # ‚ùå Hardcoded secret
```

**CORRECT**:
```python
# ‚úÖ Load from environment
import os
from dotenv import load_dotenv

load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
BETTER_AUTH_SECRET = os.getenv("BETTER_AUTH_SECRET")

if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY environment variable not set")
```

---

## üìä Success Metrics (From Specification)

When planning, ensure your design enables these measurable outcomes:

- **Performance**: Task creation < 10s, task list retrieval < 5s, conversation history load < 500ms
- **Context**: Maintain coherence across 20+ messages
- **Reliability**: 95% success rate, server survives restarts mid-conversation
- **Scalability**: 100 concurrent users without degradation
- **Accuracy**: 90% intent interpretation accuracy
- **Security**: 100% user isolation, zero cross-user data access
- **Testing**: ‚â• 85% coverage (50+ unit, 15+ integration, 5+ E2E)
- **Integration**: Tasks sync between chatbot and web UI in < 1 second

---

## üìö Key References

### Documentation
- **Phase 3 Constitution**: `.specify/memory/phase-3-constitution.md` (v1.1.0)
- **Phase 3 Specification**: `specs/002-ai-chatbot-mcp/spec.md` ‚úÖ (7 user stories, 42 FRs, 15 SCs)
- **Phase 2 Constitution**: `.specify/memory/phase-2-constitution.md` (for integration context)
- **Monorepo Guide**: `CLAUDE.md` (sections on monorepo architecture, shared components)
- **README**: `README.md` (project overview, running instructions)

### Codebase Locations
- **Phase 2 Backend**: `backend/src/` (FastAPI, models, auth)
- **Phase 2 Frontend**: `frontend-web/` (Next.js web UI)
- **Phase 3 Backend** (to be created): `backend/mcp/` (MCP server)
- **Phase 3 Frontend** (to be created): `frontend-chatbot/` (OpenAI ChatKit)
- **Shared Models**: `backend/src/models/` (Task, User, Conversation, Message)
- **Shared Auth**: `backend/src/api/auth.py` (JWT middleware)

### External Resources
- **OpenAI Agents SDK**: https://platform.openai.com/docs/agents
- **Official MCP SDK**: https://modelcontextprotocol.io/docs
- **OpenAI ChatKit**: https://platform.openai.com/docs/chatkit (or equivalent official docs)
- **SQLModel**: https://sqlmodel.tiangolo.com/
- **FastAPI**: https://fastapi.tiangolo.com/
- **Neon PostgreSQL**: https://neon.tech/docs

---

## ‚úÖ Pre-Planning Checklist

Before you execute `/sp.plan`, verify:

- [ ] Phase 3 Constitution read and understood (`.specify/memory/phase-3-constitution.md`)
- [ ] Phase 3 Specification read and validated (`specs/002-ai-chatbot-mcp/spec.md`)
- [ ] Phase 2 codebase explored (understand existing models, auth, database structure)
- [ ] Technology stack constraints acknowledged (no alternatives to OpenAI Agents SDK, MCP SDK, etc.)
- [ ] Monorepo structure understood (shared vs Phase 3-specific components)
- [ ] Three core principles internalized (agentic dev, statelessness, MCP boundary)

---

## üéØ Your Mission (AI Agent)

1. **Read the specification**: `specs/002-ai-chatbot-mcp/spec.md` (if you haven't already)
2. **Read the constitution**: `.specify/memory/phase-3-constitution.md` (if you haven't already)
3. **Explore Phase 2 codebase**: Understand existing models (`backend/src/models/`), auth (`backend/src/api/auth.py`), database setup
4. **Execute `/sp.plan`**: Design the architecture, component breakdown, MCP tool contracts, database schema, API contracts, testing strategy
5. **Validate your plan**: Ensure it complies with the constitution, uses the mandated tech stack, integrates properly with Phase 2
6. **Document your decisions**: Create ADRs for significant choices (e.g., conversation history truncation strategy, MCP server deployment model)

**Remember**: You are NOT implementing yet. You are PLANNING. The plan will guide the implementation phase. Make it comprehensive, compliant, and clear.

---

**Good luck, and may your plan honor the constitution!** üöÄ
